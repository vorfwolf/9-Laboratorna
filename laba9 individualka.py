import numpy as np #імпортуємо нампай
from random import randint #імпортуємо рандом
from time import time #імпортуємо тайм для підрахунку часу роботи функції(алгоритму сортування)

def x(): #задаємо головну фунцію, де користувач буде вибирати
    global q #задаємо глобальний масив
    while True: #створюємо умову для зациклення, в разі невірного вводу користувачем
        w = input('Самостійно бажаєте ввести числа в масив "+" чи згенерувати масив з випадкових чисел "-"?') # запитуємо
        if (w == '+'): #якщо вибираємо +, то самостійно вводимо числа в масив
            while True: #створюємо умову для зациклення, в разі невірного вводу користувачем
                try:
                    n = int(input('Введіть кількість елементів масиву"максимальна кількість-30": ')) #запитуємо користувача, кількість елементів, яку він хоче задати
                    if (n < 1 or n > 30): #кількість елементів може бути від 1 до 30
                        print('Кількість елементів масиву має бути не більше 30 і не менше 1') #в разі невірного вводу, виведемо
                        continue
                    break
                except ValueError:
                    print('Ви можете ввести лише цілі числа від 0 до 30') #помилка, у разі невірного вводу, виведемо
            q = np.zeros(n, dtype = int) #створюємо масив з нулями
            for i in range(n):
                while True:
                    try:
                        q[i] = int(input(f'q[{i}] = ')) #елементи масиву
                        break
                    except ValueError:
                        print('Введіть лише ціле число') #помилка, у разі невірного вводу, виведемо
        elif (w == '-'): #генеруємо 100000 цілих чисел
            n = 100000
            q = np.zeros(n, dtype=int) #створюємо масив з нулями
            for i in range(n):
                q[i] = randint(0, 10000) #заповнюємо рандомно кожний елемент числом від 0 до 10000
        else:
            print('Введіть лише + або -') #помилка, у разі невірного вводу, виведемо
            continue
        break
    print ('Вихідний масив:', q) #виводимо вихідний масив
    while True:
        p = input('Виберіть один з трьох методів сортування: \n1)Сортування бульбашкою;\n2)Сортування вибором;\n3)Сортування простими вставками;\n') #обираємо метод сортування
        if (p == '1'): #якшо 1, то бульбашкове сортування
            bubbleSort(q)
        elif (p == '2'): #якшо 2, то сортування вибором
            selectionSort(q)
        elif (p == '3'): #якшо 3, то сортування вставками
            insertionSort(q)
        else:
            print('Виберіть лише один з трьох запропонованих варіантів') #у разі неправильного вводу, виведемо
            continue
        break

def bubbleSort(q): #бульбашкове сортування
    h = 0 #кількість порівнянь
    g = 0 #кількість обмінів
    n = len(q) #визначимо довжину масиву
    while True: #створюємо умову для зациклення, в разі невірного вводу користувачем
        o = input('сортувати за зростанням "+" чи спаданням "-"?') #запитуємо як сортувати за зростанням чи за спаданням
        start = time() #початок відліку часу виконнаня програми
        if (o == '+'): #якщо вибираємо +, то буде сортування за зростанням
            for i in range(n): #зовнішній цикл для проходження по масиву
                flag = False #прапор для оптимізації сортування
                for j in range(0, n - i - 1): #внутрішній цикл
                    if q[j] > q[j + 1]: #якщо наступний елемент масиву менший за попередній
                        q[j], q[j + 1] = q[j + 1], q[j] #то міняємо їх місцями
                        g += 1 #+1 до кількості обміну
                        flag = True #змінюємо прапор на правду
                    h += 1 #+1 до кількості порівнянь
                if flag == False: #знінюємо прапор на хибу
                    break
        elif (o == '-'): #якщо вибираємо -, то буде сортування за спаданням
            for i in range(n):
                flag = False #прапор для оптимізації сортування
                for j in range(0, n - i - 1):
                    if q[j] < q[j + 1]: #якщо наступний елемент масиву більшиий за попередній
                        q[j], q[j + 1] = q[j + 1], q[j] #то міняємо їх місцями
                        g += 1 #+1 до кількості обміну
                        flag = True
                    h += 1 #+1 до кількості порівнянь
                if flag == False: #знінюємо прапор на хибу
                    break
        else:
            print('Введіть лише + або -') #у разі неправильного вводу, виведемо
            continue
        break

    stop = time() #кінець відліку часу роботи програми
    print('Відсортований масив:', q)
    print('Час роботи алгоритму сортування:', stop - start)
    print('Кількість порівнянь:', h)
    print('Кількість обмінів:', g)

def selectionSort(q): #сортування вибором
    h = 0 #кількість порівнянь
    g = 0 #кількість обмінів
    n = len(q) #визначимо довжину масиву
    while True: #створюємо умову для зациклення, в разі невірного вводу користувачем
        o = input('сортувати за зростанням "+" чи спаданням "-"?') #запитуємо як сортувати за зростанням чи за спаданням
        start = time() #початок відліку часу виконнаня програми
        if (o == '+'): #якщо вибираємо +, то буде сортування за зростанням
            for i in range(n): #зовнішній цикл
                min = i #визначаємо мінімальний елемент, і перевіряємо з кожним наступним
                for j in range(i + 1, n): #внутрішній цикл
                    h += 1 #+1 до кількості порівнянь
                    if q[min] > q[j]:
                        min = j #якщо знаходимо менший елемент, робимо його мінімальним
                q[i], q[min] = q[min], q[i] #і ставимо цей мінімальний елемент на позицію і
                g += 1 #+1 до кількості обміну
        elif (o == '-'): #якщо вибираємо -, то буде сортування за спаданням
            for i in range(n):
                min = i
                for j in range(i + 1, n):
                    h += 1 #+1 до кількості порівнянь
                    if q[min] < q[j]:
                        min = j
                q[i], q[min] = q[min], q[i]
                g += 1 #+1 до кількості обміну
        else:
            print('Введіть лише + або -') #у разі неправильного вводу, виведемо
            continue
        break

    stop = time() #кінець відліку часу роботи програми
    print('Відсортований масив:', q)
    print('Час роботи алгоритму сортування:', stop - start)
    print('Кількість порівнянь:', h)
    print('Кількість обмінів:', g)

def insertionSort(q): #сортування вставками
    h = 0 #кількість порівнянь
    g = 0 #кількість обмінів
    n = len(q) #визначимо довжину масиву
    while True: #створюємо умову для зациклення, в разі невірного вводу користувачем
        o = input('сортувати за зростанням "+" чи спаданням "-"?') #запитуємо як сортувати за зростанням чи за спаданням
        start = time() #початок відліку часу виконнаня програми
        if (o == '+'): #якщо вибираємо +, то буде сортування за зростанням
            for i in range(1, n): #проходимось по масиву
                j = i - 1
                key = q[i]
                while q[j] > key and j >= 0: #якщо елемент з індексом j більший за ключовий і j більше рівне нуля
                    h += 1 #+1 до кількості порівнянь
                    q[j + 1] = q[j] #то елемент правіший за елемент з індексом j стає йому рівний
                    g += 1 #+1 до кількості обміну
                    j -= 1 #ідемо в протилежну сторону
                q[j + 1] = key #елемент з індексом j+1 стає рівний ключовому
        elif (o == '-'): #якщо вибираємо -, то буде сортування за спаданням
            for i in range(1, n):
                j = i - 1
                key = q[i]
                while q[j] < key and j >= 0:
                    h += 1 #+1 до кількості порівнянь
                    q[j + 1] = q[j]
                    g += 1 #+1 до кількості обміну
                    j -= 1
                q[j + 1] = key
        else:
            print('Введіть лише + або -') #у разі неправильного вводу, виведемо
            continue
        break

    stop = time() #кінець відліку часу роботи програми
    print('Відсортований масив:', q)
    print('Час роботи алгоритму сортування:', stop - start)
    print('Кількість порівнянь:', h)
    print('Кількість обмінів:', g)

x()
